"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const vscode_languageserver_1 = require("vscode-languageserver");
const logger_1 = require("./logger");
const source_1 = require("../utilities/source");
const specifiedRulesToBeRemoved = [graphql_1.NoUnusedFragmentsRule];
exports.defaultValidationRules = [
    NoAnonymousQueries,
    NoTypenameAlias,
    NoMissingClientDirectives,
    ...graphql_1.specifiedRules.filter(rule => !specifiedRulesToBeRemoved.includes(rule))
];
function getValidationErrors(schema, document, fragments, rules = exports.defaultValidationRules) {
    const typeInfo = new graphql_1.TypeInfo(schema);
    const context = new graphql_1.ValidationContext(schema, document, typeInfo);
    if (fragments) {
        context._fragments = fragments;
    }
    const visitors = rules.map(rule => rule(context));
    graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, graphql_1.visitInParallel(visitors)));
    return context.getErrors();
}
exports.getValidationErrors = getValidationErrors;
function validateQueryDocument(schema, document) {
    try {
        const validationErrors = getValidationErrors(schema, document);
        if (validationErrors && validationErrors.length > 0) {
            for (const error of validationErrors) {
                logger_1.logError(error);
            }
            throw new logger_1.ToolError("Validation of GraphQL query document failed");
        }
    }
    catch (e) {
        console.error(e);
        throw e;
    }
}
exports.validateQueryDocument = validateQueryDocument;
function NoAnonymousQueries(context) {
    return {
        OperationDefinition(node) {
            if (!node.name) {
                context.reportError(new graphql_1.GraphQLError("Apollo does not support anonymous operations", [
                    node
                ]));
            }
            return false;
        }
    };
}
exports.NoAnonymousQueries = NoAnonymousQueries;
function NoTypenameAlias(context) {
    return {
        Field(node) {
            const aliasName = node.alias && node.alias.value;
            if (aliasName == "__typename") {
                context.reportError(new graphql_1.GraphQLError("Apollo needs to be able to insert __typename when needed, please do not use it as an alias", [node]));
            }
        }
    };
}
exports.NoTypenameAlias = NoTypenameAlias;
function NoMissingClientDirectives(context) {
    const root = context.getDocument();
    return {
        Field(node) {
            const parentType = context.getParentType();
            const fieldDef = context.getFieldDef();
            if (!parentType || !fieldDef)
                return;
            const isClientType = parentType.clientSchema &&
                parentType.clientSchema.localFields &&
                parentType.clientSchema.localFields.includes(fieldDef.name);
            const isResolvedLocally = source_1.isFieldResolvedLocally(node, root);
            if (isClientType && !isResolvedLocally) {
                let extensions = null;
                const nameLoc = node.name.loc;
                if (nameLoc) {
                    let { source, end: locToInsertDirective } = nameLoc;
                    if (node.arguments && node.arguments.length !== 0) {
                        const endOfArgs = source.body.indexOf(")", locToInsertDirective);
                        locToInsertDirective = endOfArgs + 1;
                    }
                    const codeAction = {
                        message: `Add @client directive to "${node.name.value}"`,
                        edits: [
                            vscode_languageserver_1.TextEdit.insert(source_1.positionFromSourceLocation(source, graphql_1.getLocation(source, locToInsertDirective)), " @client")
                        ]
                    };
                    extensions = { codeAction };
                }
                context.reportError(new graphql_1.GraphQLError(`Local field "${node.name.value}" must have a @client directive`, [node], null, null, null, null, extensions));
            }
            if (isClientType) {
                return false;
            }
            return;
        }
    };
}
exports.NoMissingClientDirectives = NoMissingClientDirectives;
//# sourceMappingURL=validation.js.map